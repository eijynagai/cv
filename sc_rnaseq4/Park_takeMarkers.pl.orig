#!/usr/bin/env perl
 
require("/home/park/PERL/park_basic.pl");

if(@ARGV != 2){
    print "%>perl " . $0 . " [Input_Dir] [Output_Dir]\n";
    exit;
}

$indir = shift(@ARGV);
$outdir = shift(@ARGV);

if( !defined($indir = &Chk_Dir($indir)) ){ exit; }

## Check the number 
$number_file = $indir . "numbers.txt";
if( &Chk_File($number_file) == 0){ exit; }

#mkdir and cleanup and mkdir
$outdir = &myMKDIR($outdir);
unlink($outdir);
$outdir = &myMKDIR($outdir);

$ClsMarker_dir = $indir . "ClsMarkers/";
$Module_UMAP_dir = $indir . "Modules_UMAP/";
$Module_Traj_dir = $indir . "Modules_Traj/";

if( !defined($ClsMarker_dir = &Chk_Dir($ClsMarker_dir)) ){ exit; }
if( !defined($Module_UMAP_dir = &Chk_Dir($Module_UMAP_dir)) ){ exit; }
if( !defined($Module_Traj_dir = &Chk_Dir($Module_Traj_dir)) ){ exit; }

#----------------------------------------
#Get Cluster IDs in this directory
undef(@CLSs); #keep this order
&Find_ClusterIDs();
#print join("\t", @CLSs) . "\n";

undef(%MARKERS); # $MARKERS{ gene }[cluster_id] = value

$target_dir = $ClsMarker_dir;
&Get_ClusterMarker1();

$target_dir = $Module_UMAP_dir;
&Get_ClusterMarker2();

$target_dir = $Module_Traj_dir;
&Get_ClusterMarker2();

### Write and Seperate
$Freq_Matrix = $outdir . "Freq_clsMarkers_Matrix.txt";
&Print_Markers($Freq_Matrix);
print $Freq_Matrix . "\n";
if( &Chk_File($Freq_Matrix) == 0){ exit; }


$flag = 0;
$S3_file = $indir . "Seurat3.RData";
if( &Chk_File($S3_file) == 0){ $flag++; }

if($flag != 0){
    $flag = 0;
    $S3_file = $indir . "Seurat3_subCLS.RData";
    if( &Chk_File($S3_file) == 0){
	$flag++;
    }else{
	print $S3_file . " found\n";
    }
}
if($flag){ exit; }


$flag = 0;
$CDS_file = $indir . "CDS.RData";
if( &Chk_File($CDS_file) == 0){ $flag++; }
if($flag != 0){ #not found, but is it subCLS?
    $flag = 0;
    $CDS_file = $indir . "CDS_subCLS.RData";
    if( &Chk_File($CDS_file) == 0){
	$flag++;
    }else{
	print $CDS_file . " found\n";
    }
}
if($flag){ exit; }


$thres   = 2; #>2 only
#$thres   = 3;
$ps_file = $outdir . "Plot_cells.ps";
&R_PlotCell( $CDS_file, $S3_file, $Freq_Matrix,  $thres, $outdir, $ps_file);

exit;


sub R_PlotCell{
    my ($CDS, $S3, $input_file, $thres, $this_outdir, $ps_file) = @_;

    my $r_cmd = $this_outdir . "R.cmd";
    my $r_out = $this_outdir . "R.out";
    
## Prepare R command script 
    open(OUT, ">$r_cmd");
print OUT <<EOF;
    
library(Seurat)
library(monocle3)
library(dplyr)
library(cowplot)
library(ggplot2)

library(cluster)
library(reshape2)
library(scales)
library(plyr)


load("$CDS")
load("$S3")

tbl   <- as.matrix( read.table("$input_file", header=T, sep="\\t", row.names=1) )

tbl [ tbl <= $thres ] <- 0 
idx <- apply(tbl, 1, sum) > 0
tbl <- tbl[ idx, ]

idx <- apply(tbl, 2, sum) > 0
tbl <- tbl[, idx]

#sort based on cluster 0
# because of the ordered based on clustering, can skip
idx <- sort(tbl[,1], decreasing=TRUE,index.return=TRUE)\$ix
tbl <- tbl[idx,]

## For clustering
my.hclust<- function(d) hclust(d, method="average")
my.dist  <- function(x) dist(x, method="euclidean")

A  <- tbl
A  <- t(scale(t(A), center=TRUE, scale=TRUE))

#------------------------#
HC  <- my.hclust( my.dist(A) )
#ORDER by rowname (from bottom to top in heatmap)
CLSROW <- HC\$label[ HC\$order]

CM <- cor(A)
HC2 <- my.hclust( as.dist( 1 - CM) ) 
#ORDER by colname (from ???)
CLSCOL <- HC2\$label[ HC2\$order]
#------------------------#


M <- as.data.frame( tbl )
M <- cbind(rownames(M), M)

colnames(M)[1] <- "Gene"
M.\m <- melt(M)
colnames(M.\m)[2] <- "Cluster"

# reordering M
#M.m\$Cluster <- factor(M.m\$Cluster, levels=as.character(CLSCOL) )
M.m\$Cluster <- factor(M.\m\$Cluster, levels=rev( levels(M.\m\$Cluster) ) )
M.m\$Gene <- factor(M.m\$Gene, levels=as.character(CLSROW) )

base_size  <- 6
label_size <- 22

#----------- Plot heatmap with Detection frequency
# this plot shows only over thres.freq. and may be overlaped between clusters (one gene can be included at several clusters)
p <- ggplot(M.\m, aes(\y=Cluster, x=Gene, fill=value)) + geom_tile() + scale_fill_gradient( low="white",high="red", name="Freq") 
p <- p + theme_gray(base_size=label_size)
p <- p + labs(y="", x="Consensus DEGs") + scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0,0) )

p <- p + theme(axis.ticks=element_blank(),
    axis.text.x=element_text(size=base_size*1.0, angle=90, hjust=1, vjust=0.5, colour="gray"),
    axis.text.y=element_text(size=base_size*1.7, colour="black", hjust=1), 
    legend.title=element_text(size=12), legend.text=element_text(size=12)  )

postscript("$ps_file", horizontal=T)
op <- par(cex=1.2)
p
remove(p)


#-------------- This is for ClusterX_consMakers.txt
#-------------- only a gene for only one clusters
MD <- c()
CLSs <- colnames(tbl)
for(i in 1:length(CLSs)){
    ID  <- CLSs[i] #cluster ID
    ## tbl has been already cutted by thres
    ## remove this cluster column and take genes that sum is equal to zero (i.e. specific only for this col.)
    idx <- apply( tbl[, -i], 1, sum) == 0

    # If the number of genes (i.e. specific for this cluster) is zero, go to next
    if( sum(idx) < 1 ){ next; }
    #tmp <- cbind( rownames(tbl)[idx], ID)

    this_vector <- tbl[ idx, i ] #pick up the gene and freq. of clusters 
    names(this_vector) <- rownames(tbl)[idx] # this_vector[gene name] -> freq
    
    # Take max??
    #this_vector <- this_vector[ this_vector ==  max(this_vector)]
    #tmp <- cbind( names(this_vector), ID)

    this_vector <- this_vector[ this_vector > $thres] # What is this?
    tmp <- cbind( names(this_vector), ID) # gene_name, cluster_id
    MD  <- rbind( MD, tmp) # gene_name, cluster_id

    tmp <- cbind( names(this_vector), this_vector)
    colnames(tmp) <- c("Gene",ID);
    idx <- sort(tmp[,2], decreasing=TRUE, index.return=TRUE)\$ix
    outfile   <- paste0("$this_outdir", ID, "_consMarkers.txt")
    write.table( tmp[idx,], outfile, quote=F, col.names=T, append=F, sep="\\t", row.names=F)

    remove(tmp)
    remove(this_vector)
    remove(idx)
}

#MD[ MD == 0] <- NA
plot_cells( cds, genes=MD, show_trajectory_graph=FALSE,  reduction_method = "UMAP",
	    alpha=1, 
	    label_cell_groups=TRUE, cell_size=0.5,
	    group_label_size=4, 
#	    min_expr=3 ) + scale_colour_gradient2( low="orange", mid="cyan", high="brown", name="Expression")
	    min_expr=3 ) + scale_colour_gradient( na.value="white", low="cyan", high="brown", name="Expression")

remove(MD)
dev.off()
q()

EOF
close(OUT);
# End of R command lines

# Run it
  system("R CMD BATCH --no-save $r_cmd $r_out");
  undef(@data);
  @data = `tail -3 $r_out`;
    
#    system("cat $r_out");
  if( !($data[0] =~ /^\>\sproc\.time.*/) ){
      system("cat $r_out");
      exit;
  }

  unlink($r_cmd);
  unlink($r_out);
}




sub Get_ClusterMarker1{
    my(@files, $file, $gene, $cluster, @data, $i);

    undef(@files);
    @files = glob($target_dir . "*_markers_Cls_*.txt"); #M3 and S3, markers_Cls_xx.txt
    if(scalar(@files < 1)){
	print "Zero M3 or S3 files in " . $target_dir . "\n";
	exit;
    }
    
    foreach $file (@files){
	$file =~ /.*(M3|S3)_.*markers_Cls_(\d+)\.txt/;
	$method  = $1;
	$cluster = $2;
	if( &Chk_File($file) == 0){ exit; }
	
	# last field is gene id
	$line = `head -1 $file`;
	chop($line);
	undef(@data);
	@data = split(/\t/, $line);
	$last_field = scalar(@data);
	
	undef(@data);
	@data = `cut -f $last_field $file | grep -v gene`;
	chop(@data);
	
	foreach $gene (@data){
	    if( !defined($MARKERS{$gene})){
		for($i=0; $i<scalar(@CLSs); $i++){
		    $MARKERS{ $gene }[$CLSs[$i]] = 0;
		}
	    }
	    $MARKERS{ $gene }[$cluster] += 1;

	    #if($gene eq "Pitx2"){
	#	print $gene . "\t" . $cluster . "\t" . $file . "\n";
	 #   }
	}
    }

}



sub Get_ClusterMarker2{
    my(@files, $file, $gene, $cluster, @data, $i);

    undef(@files);
    @files = glob($target_dir . "*Cluster*.txt");
    if(scalar(@files < 1)){
	print "Zero M3 or S3 files in " . $target_dir . "\n";
	exit;
    }

    foreach $file (@files){
	$file =~ /.*Cluster(\d+)_markerModule.*\.txt/;
	$cluster = $1;
	if( &Chk_File($file) == 0){ exit; }

	# last field is gene id
	$line = `head -1 $file`;
	chop($line);
	undef(@data);
	@data = split(/\t/, $line);
	$last_field = scalar(@data);

	undef(@data);
	@data = `cut -f $last_field $file | grep -v gene`;
	chop(@data);
	
	foreach $gene (@data){
	    if( !defined($MARKERS{$gene})){
		for($i=0; $i<scalar(@CLSs); $i++){
		    $MARKERS{ $gene }[$CLSs[$i]] = 0;
		}
	    }
	    $MARKERS{ $gene }[$cluster] += 1;

	    #if($gene eq "Pitx2"){
	#	print $gene . "\t" . $cluster . "\t" . $file . "\n";
	 #   }

	}

    }

}




sub Print_Markers{
    my $outfile = $_[0];
    my ($i, $gene );

    open(PM, ">$outfile");
    print PM "Gene";
    for($i=0; $i<scalar(@CLSs); $i++){
	print PM "\t" . "Cluster" . $CLSs[$i];
    }
    print PM "\n";
    
    foreach $gene (sort {$a cmp $b} keys %MARKERS){
	$outline = $gene;
	for($i=0; $i<scalar(@CLSs); $i++){
	    $outline .= "\t" . $MARKERS{ $gene }[ $CLSs[$i] ];
	}
	$outline .= "\n";
	print PM $outline;

	#if($gene eq "Pitx2"){
	 #   print $outline . "\n";
	#}
    }
    close(PM);
}


#&Find_ClusterIDs();

sub Find_ClusterIDs{
    undef(@CLSs);

    undef(@files);
    @files = glob($ClsMarker_dir . "*_markers_Cls_*.txt"); #M3 and S3, markers_Cls_xx.txt
    if(scalar(@files < 1)){
	print "Zero M3 or S3 files in " . $ClsMarker_dir . "\n";
	exit;
    }

    foreach $file (@files){
	$file =~ /.*(M3|S3)_markers_Cls_(\d+).txt/;
	$method  = $1;
	$cluster = $2;
	push(@CLSs, $cluster);
    }
    @CLSs = &Get_Unique_Elements_Sort_Num( @CLSs);
    
    undef(@files);
    @files = glob($Module_UMAP_dir . "Cluster*_markerModule*.txt");
    if(scalar(@files < 1)){
	print "Zero Cluster marker files in " . $Module_UAMP_dir . "\n";
	exit;
    }
    foreach $file (@files){
	$file =~ /.*Cluster(\d+)_markerModule.*\.txt/;
	$cluster = $1;
	push(@CLSs, $cluster);
    }
    @CLSs = &Get_Unique_Elements_Sort_Num( @CLSs);
    
    
    undef(@files);
    @files = glob($Module_Traj_dir . "Cluster*_markerModule*.txt");
    if(scalar(@files < 1)){
	print "Zero Cluster marker files in " . $Module_Traj_dir . "\n";
	exit;
    }
    foreach $file (@files){
	$file =~ /.*Cluster(\d+)_markerModule.*\.txt/;
	$cluster = $1;
	push(@CLSs, $cluster);
    }
    @CLSs = &Get_Unique_Elements_Sort_Num( @CLSs);
}
